#TIL/알쓸신컴
# 게시물 조회수 성능 최적화에 대한 고찰
## 조회수에 대한 성능 최적화에 대한 필요성
0. **계기**
교환학생 대상 다국어 지원 중고 거래 서비스의 리소스 API 서버를 설계하고 구현하던 중, 특정 게시물에 대한 조회 수, 좋아요 수를 처리할 때에 매번 DB 에 접근하게 된다면 트래픽이 적을 때에는 큰 상관이 없겠지만, 서비스가 스케일 아웃하였을 때에 성능이 현저하게 떨어질 것 같다는 생각이 들게 되었고, 조회 수, 좋아요 수를 효율적으로 다룰 수 있는 부분에 대하여 찾아보게 되었다.

2. **데이터베이스 잠금**
내가 자주 사용하는 mysql 의 경우 InnoDB 를 storage engine 으로 사용하게 된다. InnoDB 는 update 를 수행할 때에 where 절에 따라서 인덱스를 잠구고 update 를 수행하게 된다. 따라서 잠긴 상황에서 다른 조회 요청이 들어올 경우 트랜잭션은 기다리게 된다. 따라서 글 조회를 위한 update query 를 실행할 때에 다른 사용자가 글을 조회하는 것이 느려질 수 있다.

2. **데이터베이스 Query call 의 수**
보통의 커뮤니티나 서비스의 경우 실시간 조회수에 대한 빠른 처리가 중요한 부분이다. 간단하게 처리할 경우, 글을 조회할 때에 **글 조회 Query + 글 조회수 증가 Query** 총 2번의 Query 가 DB 에 요청된다. 시간당 1개의 글에 약 10000번의 조회가 일어난다면, 하루 24시간 * 10000번 * 글의 개수로 따진다면, 글의 개수가 1000개만되더라도 2억 4천번의 추가 Query 가 발생하게 되는 것이다. 

## 성능 최적화에 대한 고려 사항
1. 실시간으로 인기가 있는 글을 보여주어야 하는 커뮤니티의 경우 실시간 조회수가 중요

2. 유튜브와 같이 조회수가 수입과 직결되는 경우 **여러 검증들( 중복조회, 특정 시간 이상 시청 )** 을 거치고 정확한 조회수가 중요

따라서 내가 개발하고 있는 서비스의 경우 어느정도 실시간 조회수가 중요하다고 여겨진다.

## 성능 최적화 방법에 대하여 고려해본 것들
### 테이블을 두개로 나눈다!
조회수를 위한 update 때문에 글의 인덱스가 잠기는 것이 문제라면 조회 수, 좋아요 수와 같은 count table 을 게시물 table 과 따로 두면 되지 않을까? 찾아보니 테이블을 나누어 처리한다고 했을때에도 결국, 글 조회와, 조회수 UPDATE가 모두 이루어져야 한 요청이 정상적으로 처리된것이기 때문에, 이를 하나의 트랜잭션에서 구현하게 된다고 한다. 결국 같은 일을 나누어 처리하는것 밖에 안되는 것이고 성능은 저하된다.

이와 비슷하게 게시물 table 과 count table 을 나눈 후, 게시물 table 을 캐싱하여 레디스에 두는 것은 어떨까? 라고 생각하였다. 게시물 table 에 대한 조회 요청은 캐시에서 처리하므로 성능 향상을 도모할 수 있고, 좋아요 수와 조회 수 두 개의 컬럼만 가진 테이블은 DB에서 조회하는 것이다. 하지만 컬럼 수가 적더라도 **데이터베이스 Query call 의 수** 는 여전히 해결되지 못하게 되고 휘발성을 가진 레디스에서 DB 에 게시물을 일정 시간 마다 update 할 때에 count table 과 조인되는 비용 또한 생기게 될 것 같아 스트레스 테스트를 수행해봐야 알 것 같은 불확실한 방법이라고 생각하였다.

### 서버에서 변수 단에 저장을 해놓고 한번에 UPDATE!
글을 조회할 때에 이 글이 조회되었음을 메모리 어딘가에 저장해두고 한번에 update 절을 수행한다면 큰 성능 향상을 도모할 수 있을 것으로 생각했다. 
```
 public BoardDetail read(Long boardId) {
        Board board = boardRepository.findById(boardId)
               .get();
 
        tempHit += 1;
 
        if (tempHit > 10000) {
            board.increaseViewCount(tempHit);
            tempHit = 0;
       }
 
        return new BoardDetail(board.getBoardId(), board.getTitle(), board.getContent(), board.getHit());
   }
```

하지만 실제 서비스, 프로덕트에서는 위와 같이 진행되어서는 안된다고 한다. 인기가 없는 게시물의 경우 위의 코드와 같이 조회가 10000번이 안될 수도 있기 때문이다. 또한, Bean의 경우 여러 스레드에서 공유되어 사용하므로 공유되는 멤버 변수를 두면 안된다고 한다. 
마지막으로 내가 진행중인 프로덕트의 경우 좋아요, 조회 수가 실시간으로 반영되는 것이 꽤 중요하다고 여겨지기 때문에 해서는 안되는 방법이라고 생각하였다.

### CQRS & Event Sourcing
CQRS는 커맨드(데이터 변경 처리)와 쿼리(데이터 조회 처리)를 분리 시켜, 도메인의 복잡도를 줄이고, 각각의 성능향상을 도모할 수 있도록 해주는 하나의 프로그래밍 원칙이라고 한다. 글 조회 요청이 들어온 경우 글 조회를 위한 데이터만을 반환하고, 글 조회 이벤트를 발행하는 것으로 처리를 끝냅니다. 이렇게하면, 조회수 증가를 위한 별도 처리 로직이 전혀 들어가지 않기 때문에, 코드가 더욱 명확해지고, 글 조회 처리만을 하기 때문에 성능향상을 도모할 수 있다고 한다. 따라서 이 방법을 채택하여 공부하고 나의 프로젝트에 적용시켜보려고 한다.

다음 게시물에서는 **CQRS & Event Sourcing** 에 대한 원리와 개념을 자세하게 공부하고 Spring 에서 적용할 수 있는 방법에 대하여 포스팅 할 것이다.

# REFERENCE
1. [ApplicationKnowhow/Server - 게시판 조회수 기능 성능 최적화](https://galid1.tistory.com/791?category=799978)
2. [Redis를 사용한 View count, 방문자 수 관리하는 효과적인 방법은?](https://webisfree.com/2017-11-13/redis%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-view-count-%EB%B0%A9%EB%AC%B8%EC%9E%90-%EC%88%98-%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94-%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-%EB%B0%A9%EB%B2%95%EC%9D%80)